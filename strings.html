<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<!-- 	$Header$	 -->
<html> <head>
<title>The Common Lisp Cookbook - Strings</title>
<style type="text/css">
pre { margin-left:20px; }
</style>

</head>

<body bgcolor=white>
<h1><a href="index.html">The Common Lisp Cookbook</a> - Strings</h1>

<table border=0 cellpadding=0 cellspacing=0 width=550><tr valign=top><td width=550>


<h2>Content</h2>
<ul>
<li><a href="#substrings">Accessing Substrings</a>
<li><a href="#chars">Accessing Individual Characters</a>
<li><a href="#manip">Manipulating Parts of a String</a>
<li><a href="#concat">Concatenating Strings</a>
<li><a href="#process">Processing a String One Character at a Time</a>
<li><a href="#reverse">Reversing a String by Word or Character</a>
<li><a href="#case">Controlling Case</a>
<li><a href="#trim">Trimming Blanks from the Ends of a String</a>
<li><a href="#symbols">Converting between Symbols and Strings</a>
<li><a href="#conv-chars">Converting between Characters and
  Strings</a>
<li><a href="#find-el">Finding an Element of a String</a>
<li><a href="#find-sub">Finding a Substring of a String</a>
<li><a href="#number">Converting a String to a Number</a>
<li><a href="#compare">Comparing Strings</a>
  </ul>

  The most important thing to know about strings in Common Lisp is
probably that they are arrays and thus also sequences. This implies
that <em>all</em> concepts that are applicable to arrays and sequences
also apply to strings. If you can't find a particular string function,
make sure you've also searched for the more general array or sequence
functions. We'll only cover a fraction of what can be done with and to
strings here.


<a name="substrings"><h3>Accessing Substrings</h3></a>

  As a string is a sequence, you can access substrings with the <a
  href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_subseq.htm">SUBSEQ</a> function. The index into the string is, as always, zero-based. The third, optional, argument is the index of the first character which is not a part of the substring, it is <em>not</em> the length of the substring.
  
<PRE>
* (defparameter *my-string* "Groucho Marx")
*MY-STRING*
* (subseq *my-string* 8)
"Marx"
* (subseq *my-string* 0 7)
"Groucho"
* (subseq *my-string* 1 5)
"rouc"
</PRE>
  
  You can also manipulate the substring if you use SUBSEQ together
  with <a
  href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/m_setf_.htm">SETF</A>.
  
<PRE>
* (defparameter *my-string* "Harpo Marx")
*MY-STRING*
* (subseq *my-string* 0 5)
"Harpo"
* (setf (subseq *my-string* 0 5) "Chico")
"Chico"
* *my-string*
"Chico Marx"
</PRE>
  
  But note that the string isn't &quot;stretchable&quot;. To cite from the
  <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/index.html">HyperSpec</a>: &quot;If the subsequence and the new sequence are not of
  equal length, the shorter length determines the number of elements
  that are replaced.&quot;
  For example:
  
<PRE>
* (defparameter *my-string* "Karl Marx")
*MY-STRING*
* (subseq *my-string* 0 4)
"Karl"
* (setf (subseq *my-string* 0 4) "Harpo")
"Harpo"
* *my-string*
"Harp Marx"
* (subseq *my-string* 4)
" Marx"
* (setf (subseq *my-string* 4) "o Marx")
"o Marx"
* *my-string*
"Harpo Mar"
</PRE>

<a name="chars"><h3>Accessing Individual Characters</h3></a>
You can use the function <a
  href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_char_.htm">CHAR</A> to access individual characters of a string. CHAR can also be used in conjunction with SETF.
  
  <PRE>
* (defparameter *my-string* "Groucho Marx")
*MY-STRING*
* (char *my-string* 11)
#\x
* (char *my-string* 7)
#\Space
* (char *my-string* 6)
#\o
* (setf (char *my-string* 6) #\y)
#\y
* *my-string*
"Grouchy Marx"
</PRE>

Note that there's also <a
  href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_char_.htm">SCHAR</A>. If efficiency is important, SCHAR can be a bit faster
where appropriate.
<br>&nbsp;</br>
Because strings are arrays and thus sequences, you can also use the more
generic functions <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_aref.htm">AREF</a> and <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_elt.htm">ELT</a> (which are
more general while CHAR might be implemented more efficiently).

<PRE>
* (defparameter *my-string* "Groucho Marx")
*MY-STRING*
* (aref *my-string* 3)
#\u
* (elt *my-string* 8)
#\M
</PRE>

<a name="manip"><h3>Manipulating Parts of a String</h3></a>

  There's a slew of (sequence) functions that can be used to
  manipulate a string and we'll only provide some
  examples here. See the <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/c_sequen.htm">sequences
  dictionary</a> in the HyperSpec for more.

<pre>
* (remove #\o "Harpo Marx")
"Harp Marx"
* (remove #\a "Harpo Marx")
"Hrpo Mrx"
* (remove #\a "Harpo Marx" :start 2)
"Harpo Mrx"
* (remove-if #'upper-case-p "Harpo Marx")
"arpo arx"
* (substitute #\u #\o "Groucho Marx")
"Gruuchu Marx"
* (substitute-if #\_ #'upper-case-p "Groucho Marx")
"_roucho _arx"
* (defparameter *my-string* "Zeppo Marx")
*MY-STRING*
* (replace *my-string* "Harpo" :end1 5)
"Harpo Marx"
* *my-string*
"Harpo Marx"
</pre>

<a name="concat"><h3>Concatenating Strings</h3></a>

The name says it all: <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_concat.htm">CONCATENATE</a>
is your friend. Note that this a generic sequence function and you
have to provide the result type as the first argument.

<pre>
* (concatenate 'string "Karl" " " "Marx")
"Karl Marx"
* (concatenate 'list "Karl" " " "Marx")
(#\K #\a #\r #\l #\Space #\M #\a #\r #\x)
</pre>



If you have to construct a string out of many parts, all of these calls
   to CONCATENATE seem wasteful, though. There are at least three other good ways to construct a string
   piecemeal, depending on what exactly your data is.

   If you build your string one character at a time, make it an <em>adjustable</em> VECTOR
   (a one-dimensional <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/15_.htm">ARRAY</a>) of type character with a fill-pointer of
zero, then use <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_vec_ps.htm">VECTOR-PUSH-EXTEND</a> on it.  That way, you can also
   give hints to the system if you can estimate how long the string
   will be. (See the optional third argument to VECTOR-PUSH-EXTEND.)

<PRE>
* (defparameter *my-string* (make-array 0
                                        :element-type 'character
                                        :fill-pointer 0
                                        :adjustable t))
*MY-STRING*
* *my-string*
""
* (dolist (char '(#\Z #\a #\p #\p #\a))
    (vector-push-extend char *my-string*))
NIL
* *my-string*
"Zappa"
</PRE>

If the string will be constructed out of (the printed
   representations of) arbitrary objects, (symbols, numbers,
   characters, strings, ...), you can use <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_format.htm">FORMAT</a> with an output stream argument
of <code>NIL</code>. This directs FORMAT to return the indicated output as a string.

<pre>
* (format nil "This is a string with a list ~A in it"
          '(1 2 3))
"This is a string with a list (1 2 3) in it"
</pre>

We can use the looping constructs of the FORMAT mini language to
emulate CONCATENATE.

<pre>
* (format nil "The Marx brothers are:~{ ~A~}."
          '("Groucho" "Harpo" "Chico" "Zeppo" "Karl"))
"The Marx brothers are: Groucho Harpo Chico Zeppo Karl."
</pre>

FORMAT can do a lot more processing but it has a relatively arcane
syntax. After this last example, you can find the details in <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/22_c.htm">the CLHS section about formatted output</a>.

<pre>
* (format nil "The Marx brothers are:~{ ~A~^,~}."
          '("Groucho" "Harpo" "Chico" "Zeppo" "Karl"))
"The Marx brothers are: Groucho, Harpo, Chico, Zeppo, Karl."
</pre>

Another way to create a string out of the printed representation of
various object is using  <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/m_w_out_.htm">WITH-OUTPUT-TO-STRING</a>.  The value of
   this handy macro is a string containing everything that was output
   to the string stream within the body to the macro.  This means you
   also have the full power of <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_format.htm">FORMAT</a> at your disposal, should you
   need it.

<pre>
* (with-output-to-string (stream)
    (dolist (char '(#\Z #\a #\p #\p #\a #\, #\Space))
      (princ char stream))
    (format stream "~S - ~S" 1940 1993))
"Zappa, 1940 - 1993"
</pre>

<a name="process"><h3>Processing a String One Character at a
Time</h3></a>
Use the <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_map.htm">MAP</a>
function to process a string one character at a time.

<PRE>
* (defparameter *my-string* "Groucho Marx")
*MY-STRING*
* (map 'string #'(lambda (c) (print c)) *my-string*)
#\G 
#\r 
#\o 
#\u 
#\c 
#\h 
#\o 
#\Space 
#\M 
#\a 
#\r 
#\x 
"Groucho Marx"
</PRE>

Or do it with <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/06_a.htm">LOOP</a>.

<PRE>
* (loop for char across "Zeppo"
        collect char)
(#\Z #\e #\p #\p #\o)
</PRE>

<a name="reverse"><h3>Reversing a String by Word or Character</h3></a>
Reversing a string by character is easy using the built-in <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_revers.htm">REVERSE</a>
function (or its <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/26_glo_d.htm#destructive">destructive</a> counterpart NREVERSE).

<PRE>
*(defparameter *my-string* "DSL")
*MY-STRING*
* (reverse *my-string*)
"LSD"
</PRE>

There's no one-liner in CL to reverse a string by word (like you
would do it in Perl with <code>split</code> and
<code>join</code>). You either have to use function from an external
library like <a
href="http://ww.telent.net/cliki/SPLIT-SEQUENCE">SPLIT-SEQUENCE</a> or
you have to roll your own solution. Here's an attempt:

<pre>
* (defun split-by-one-space (string)
    "Returns a list of substrings of string
divided by ONE space each.
Note: Two consecutive spaces will be seen as
if there were an empty string between them."
    (loop for i = 0 then (1+ j)
          as j = (position #\Space string :start i)
          collect (subseq string i j)
          while j))
SPLIT-BY-ONE-SPACE
* (split-by-one-space "Singing in the rain")
("Singing" "in" "the" "rain")
* (split-by-one-space "Singing in the  rain")
("Singing" "in" "the" "" "rain")
* (split-by-one-space "Cool")
("Cool")
* (split-by-one-space " Cool ")
("" "Cool" "")
* (defun join-string-list (string-list)
    "Concatenates a list of strings
and puts spaces between the elements."
    (format nil "~{~A~^ ~}" string-list))
JOIN-STRING-LIST
* (join-string-list '("We" "want" "better" "examples"))
"We want better examples"
* (join-string-list '("Really"))
"Really"
* (join-string-list '())
""
* (join-string-list
   (nreverse
    (split-by-one-space
     "Reverse this sentence by word")))
"word by sentence this Reverse"
</pre>

<a name="case"><h3>Controlling Case</h3></a>
Common Lisp has a couple of <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_stg_up.htm">functions to control the case of a
string</a>. 

<pre>
* (string-upcase "cool")
"COOL"
* (string-upcase "Cool")
"COOL"
* (string-downcase "COOL")
"cool"
* (string-downcase "Cool")
"cool"
* (string-capitalize "cool")
"Cool"
* (string-capitalize "cool example")
"Cool Example"
</pre>

These functions  take :START end :END keyword arguments so you can
optionally only manipulate a part of the string. They also have
destructive counterparts whose names starts with &quot;N&quot;.

<pre>
* (string-capitalize "cool example" :start 5)
"cool Example"
* (string-capitalize "cool example" :end 5)
"Cool example"
* (defparameter *my-string* "BIG")
*MY-STRING*
* (defparameter *my-downcase-string* (nstring-downcase *my-string*))
*MY-DOWNCASE-STRING*
* *my-downcase-string*
"big"
* *my-string*
"big"
</pre>

Note this potential caveat: According to the HyperSpec, "for
STRING-UPCASE, STRING-DOWNCASE, and STRING-CAPITALIZE, <em>string</em>
is not modified. However, if no characters in string require
conversion, the result may be either <em>string</em> or a copy of it,
at the implementation's discretion." This implies the last result in
the following example is implementation-dependent - it may either be
&quot;BIG&quot; or &quot;BUG&quot;. If you want to be sure, use <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_cp_seq.htm">COPY-SEQ</a>.

<pre>
* (defparameter *my-string* "BIG")
*MY-STRING*
* (defparameter *my-upcase-string* (string-upcase *my-string*))
*MY-UPCASE-STRING*
* (setf (char *my-string* 1) #\U)
#\U
* *my-string*
"BUG"
* *my-upcase-string*
"BIG"
</pre>

<a name="trim"><h3>Trimming Blanks from the Ends of a String</h3></a>
Not only can you trim blanks, but you can get rid of arbitary characters.
The functions <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_stg_tr.htm">STRING-TRIM, STRING-LEFT-TRIM and STRING-RIGHT-TRIM</a>
return a substring of their second argument where all characters that
are in the first argument are removed  off the beginning and/or
the end. The first argument can be any <em>sequence</em> of characters.

<pre>
* (string-trim " " " trim me ")
"trim me"
* (string-trim " et" " trim me ")
"rim m"
* (string-left-trim " et" " trim me ")
"rim me "
* (string-right-trim " et" " trim me ")
" trim m"
* (string-right-trim '(#\Space #\e #\t) " trim me ")
" trim m"
* (string-right-trim '(#\Space #\e #\t #\m) " trim me ")
</pre>

Note: The caveat mentioned in the section about <a
href="#case">Controlling Case</a> also applies here.

<a name="symbols"><h3>Converting between Symbols and Strings</h3></a>
The function <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_intern.htm">INTERN</a>
will &quot;convert&quot; a string to a symbol. Actually, it will check
whether the symbol denoted by the string (its first argument) is
already accessible in the package (its second, optional, argument
which defaults to the current package) and enter it, if
necessary, into this package. It is beyond the scope of this chapter
to explain all the concepts involved and to address the second return
value of this function. See <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/11_.htm">the
CLHS chapter about packages</a> for details.
<br>&nbsp;<br>
Note that the case of the string is relevant.

<pre>
* (in-package "COMMON-LISP-USER")
#&lt;The COMMON-LISP-USER package, 35/44 internal, 0/9 external&gt;
* (intern "MY-SYMBOL")
MY-SYMBOL
NIL
* (intern "MY-SYMBOL")
MY-SYMBOL
:INTERNAL
* (export 'MY-SYMBOL)
T
* (intern "MY-SYMBOL")
MY-SYMBOL
:EXTERNAL
* (intern "My-Symbol")
|My-Symbol|
NIL
* (intern "MY-SYMBOL" "KEYWORD")
:MY-SYMBOL
NIL
* (intern "MY-SYMBOL" "KEYWORD")
:MY-SYMBOL
:EXTERNAL
</pre>

To do the opposite, convert from a symbol to a string, use <a
  href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_symb_2.htm">SYMBOL-NAME</a> or <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_string.htm">STRING</a>.

<pre>
* (symbol-name 'MY-SYMBOL)
"MY-SYMBOL"
* (symbol-name 'my-symbol)
"MY-SYMBOL"
* (symbol-name '|my-symbol|)
"my-symbol"
* (string 'howdy)
"HOWDY"
</pre>

<a name="conv-chars"><h3>Converting between Characters and
  Strings</h3></a>
You can use <a
  href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_coerce.htm">COERCE</A> to convert a string of length 1 to a character. You can also use COERCE to convert any sequence of characters into a string. You can <em>not</em> use COERCE to convert a character to a string, though - you'll have to use <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_string.htm">STRING</a> instead.
  
<pre>
* (coerce "a" 'character)
#\a
* (coerce (subseq "cool" 2 3) 'character)
#\o
* (coerce "cool" 'list)
(#\c #\o #\o #\l)
* (coerce '(#\h #\e #\y) 'string)
"hey"
* (coerce (nth 2 '(#\h #\e #\y)) 'character)
#\y
* (defparameter *my-array* (make-array 5 :initial-element #\x))
*MY-ARRAY*
* *my-array*
#(#\x #\x #\x #\x #\x)
* (coerce *my-array* 'string)
"xxxxx"
* (string 'howdy)
"HOWDY"
* (string #\y)
"y"
* (coerce 'string #\y)

Type-error in KERNEL::OBJECT-NOT-TYPE-ERROR-HANDLER:
   #\y is not of type (OR CONS CLASS SYMBOL)
</pre>

<a name="find-el"><h3>Finding an Element of a String</h3></a>

Use <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_find_.htm">FIND</a>,
<a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_pos_p.htm">POSITION</a>,
and their -IF counterparts to find characters in a string.

<pre>
* (find #\t "The Hyperspec contains approximately 110,000 hyperlinks." :test #'equal)
#\t
* (find #\t "The Hyperspec contains approximately 110,000 hyperlinks." :test #'equalp)
#\T
* (find #\z "The Hyperspec contains approximately 110,000 hyperlinks." :test #'equalp)
NIL
* (find-if #'digit-char-p "The Hyperspec contains approximately 110,000 hyperlinks.")
#\1
* (find-if #'digit-char-p "The Hyperspec contains approximately 110,000 hyperlinks." :from-end t)
#\0
* (position #\t "The Hyperspec contains approximately 110,000 hyperlinks." :test #'equal)
17
* (position #\t "The Hyperspec contains approximately 110,000 hyperlinks." :test #'equalp)
0
* (position-if #'digit-char-p "The Hyperspec contains approximately 110,000 hyperlinks.")
37
* (position-if #'digit-char-p "The Hyperspec contains approximately 110,000 hyperlinks." :from-end t)
43
</pre>

Or use <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_countc.htm">COUNT</a>
and friends to count characters in a string.

<pre>
* (count #\t "The Hyperspec contains approximately 110,000 hyperlinks." :test #'equal)
2
* (count #\t "The Hyperspec contains approximately 110,000 hyperlinks." :test #'equalp)
3
* (count-if #'digit-char-p "The Hyperspec contains approximately 110,000 hyperlinks.")
6
* (count-if #'digit-char-p "The Hyperspec contains approximately 110,000 hyperlinks." :start 38)
5
</pre>

<a name="find-sub"><h3>Finding a Substring of a String</h3></a>

The function <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_search.htm">SEARCH</a>
can find substrings of a string.

<pre>
* (search "we" "If we can't be free we can at least be cheap")
3
* (search "we" "If we can't be free we can at least be cheap" :from-end t)
20
* (search "we" "If we can't be free we can at least be cheap" :start2 4)
20
* (search "we" "If we can't be free we can at least be cheap" :end2 5 :from-end t)
3
* (search "FREE" "If we can't be free we can at least be cheap")
NIL
* (search "FREE" "If we can't be free we can at least be cheap" :test #'char-equal)
15
</pre>

<a name="number"><h3>Converting a String to a Number</h3></a>

CL provides the <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_parse_.htm">PARSE-INTEGER</a>
to convert a string representation of an integer to the corresponding
numeric value. The second return value is the index into the string where the
parsing stopped.

<pre>
* (parse-integer "42")
42
2
* (parse-integer "42" :start 1)
2
2
* (parse-integer "42" :end 1)
4
1
* (parse-integer "42" :radix 8)
34
2
* (parse-integer " 42 ")
42
3
* (parse-integer " 42 is forty-two" :junk-allowed t)
42
3
* (parse-integer " 42 is forty-two")


Error in function PARSE-INTEGER:
   There's junk in this string: " 42 is forty-two".
</pre>

PARSE-INTEGER doesn't understand radix specifiers like <code>#X</code>,
nor is there a built-in function to parse other numeric types. You
could use <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_rd_fro.htm">READ-FROM-STRING</a>
in this case, but be aware that the full <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/02_b.htm">reader</a>
is in effect if you're using this function.

<pre>
* (read-from-string "#X23")
35
4
* (read-from-string "4.5")
4.5
3
* (read-from-string "6/8")
3/4
3
* (read-from-string "#C(6/8 1)")
#C(3/4 1)
9
* (read-from-string "1.2e2")
120.00001
5
* (read-from-string "symbol")
SYMBOL
6
* (defparameter *foo* 42)
*FOO*
* (read-from-string "#.(setq *foo* \"gotcha\")")
"gotcha"
23
* *foo*
"gotcha"
</pre>

<a name="compare"><h3>Comparing Strings</h3></a>
The general functions
<a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_equal.htm">EQUAL</a>
and 
<a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_equalp.htm">EQUALP</a>
can be used to test whether two strings are equal. The strings are
compared element-by-element, either in a case-sensitive manner (EQUAL)
or not (EQUALP). There's also a bunch of <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_stgeq_.htm">string-specific
comparison functions</a>. You'll want to use these if you're deploying
<em>implementation-defined</em> attributes of characters. Check your
vendor's documentation in this case.
<br>&nbsp;<br>

Here are a few examples. Note that all functions that test for
inequality return the position of the first mismatch as a <a
href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/26_glo_g.htm#generalized_boolean">generalized
boolean</a>.
You can also use the generic sequence function <a href="http://www.xanalys.com/software_tools/reference/HyperSpec/Body/f_mismat.htm">MISMATCH</a>
if you need more versatility.

<pre>
* (string= "Marx" "Marx")
T
* (string= "Marx" "marx")
NIL
* (string-equal "Marx" "marx")
T
* (string< "Groucho" "Zeppo")
0
* (string< "groucho" "Zeppo")
NIL
* (string-lessp "groucho" "Zeppo")
0
* (mismatch "Harpo Marx" "Zeppo Marx" :from-end t :test #'char=)
3
</pre>

</td></tr></table>

  <hr>
<a href="license.html">Copyright</a> &copy; 2002 The Common Lisp Cookbook Project
<address>http://cl-cookbook.sourceforge.net/</address>
<!-- hhmts start --> Last modified: Thu Feb 14 02:05:58 CET 2002 <!-- hhmts end -->
</body> </html>
