<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<!-- 	$Header$	 -->
<html> <head>
<title>The Common Lisp Cookbook - Threads</title>
<style type="text/css">
 <!--
    pre { margin-left:20px; background-color:#e0e0e0 }
    code { background-color:#e0e0e0 }
 -->
</style>

</head>

<body bgcolor="white">
<h1><a href="index.html">The Common Lisp Cookbook</a> - Threads</h1>


<p>This page is only partially written. Still, half is better than
none...</p>

<h2>Contents</h2>

<ul>
<li><a href="#why_bother">Why bother?</a></li>
<li><a href="#basics">Basics</a></li>
<li><a href="#output">Where's my output?</a></li>
<li><a href="#waiting">Waiting</a></li>
<li><a href="#state">Per-thread state</a></li>
<li><a href="#initializing">Initializing multithreading</a>  <i>(under construction)</i></li>
<li><i>and more</i></li>
</ul>

<p>By <cite>threads</cite>, I mean separate execution strands within a
single Lisp process, sharing the same address space. Typically,
execution is automatically switched between these strands by the
system (either by the lisp kernel or by the operating system) so that
tasks appear to be completed in parallel (asynchronously). This page
discusses the creation and management of threads and of the
interactions between them. For information about the interaction of
lisp and other <cite>processes</cite>, see <a
href="os.html">Interfacing with your OS</a>.</p>

<p>The ANSI Common Lisp standard doesn't mention this topic. So almost
everything that can be said here depends on your OS and your
implementation. It's not just a question of different symbols in
different packages (although that might be enough to get you started,
so see the <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/portableaserve/portableaserve/acl-compat/">acl-compat</a>
package at Sourceforge and in particular the files whose names match
"acl-mp-*.lisp") - concepts can vary too.</p>

<p>Speaking of implementations, the following discussion currently
refers only to <a href="http://www.xanalys.com/">Xanalys</a> <a
href="http://www.xanalys.com/software_tools/products/">LispWorks</a>.
It has been tested on LispWorks for Windows version 4.2.6 running on
Windows NT (SP 6). Your mileage may vary. I will add "support" for
other implementations and operating systems to this page later, if I
have the time and access to the appropriate materials.</p>

<a name="why_bother"></a>
<h3>Why bother?</h3>

<p>The first question to resolve is: why bother with threads?
Sometimes your answer will simply be that your application is so
straightforward that you need not concern youself with threads at
all. But in many other cases it's difficult to imagine how a
sophisticated application can be written without multi-threading. For
example:</p>

<ul>

<li>you might be writing a server which needs to be able to respond to
more than one user / connection at a time;</li>

<li>you might want to perform some background activity, without
halting the main application while this is going on;</li>

<li>you might want to keep the application running while waiting for
some system resource to become available;</li>

<li>you might need to interface with some other system which requires
multithreading (for example, "windows" under Windows generally run in
their own threads);</li>

<li>you might want to associate different contexts (e.g. different
dynamic bindings) with different parts of the application;</li>

<li>you might even have the simple need to do two things at once.</li>

</ul>

<a name="basics"></a><h3>Basics</h3>

<p>In order to run a function in a separate thread, you need to do two
things.</p>

<ol>

<li>Make sure that multithreading is running. By default,
multithreading is always running in the LispWorks for Windows
environment so in this case there is nothing to do. See
<a href="#initializing">initializing multithreading</a> below to find
out how to get threads running on other platforms.</li>

<li>Now call your function, in its new thread. For example:

<pre>
(defvar *foo* 0)
(defun foo () (incf *foo*))
(mp:process-run-function "Incrementing *foo*" nil 'foo)
*foo*  => 1
</pre>

</li>
</ol>

<p>In the above example, you created a new thread called
<code>"Incrementing *foo*"</code>. The function <code>foo</code> was
invoked (with no arguments) in that thread. When <code>foo</code>
returned, the thread no longer had any work to do and so was
terminated.</p>

<p>Note the following:</p>

<ul>

<li>The first argument to <code>mp:process-run-function</code> is a
string naming the thread. You don't have to make the names unique, but
it's a smart move if you do in actual code, as it's a great way to
tell your threads apart when you're debugging them. When playing
around in the listener, you'll often find no harm in using an empty
string here.</li>

<li>The second argument to <code>mp:process-run-function</code> is a
list of <cite>process initialization keywords</cite>. You'll almost
always leave this empty (so you needn't bother about any details).</li>

<li>The third argument is the function to invoke in the new
thread. This should be a function designator, for example, an <code>fboundp</code>
symbol or a <code>lambda</code> form. </li>

<li>Any remaining arguments to <code>mp:process-run-function</code>
are passed to your function. So calls to
<code>mp:process-run-function</code> look like calls to
<code>funcall</code> with two additional arguments at the
beginning.</li>

<li>A call to <code>mp:process-run-function</code> returns immediately
(the return value is of type <code>mp:process</code>), while the new
thread executes asynchronously.</li>

</ul>

<p>Another simple example:</p>

<pre>
CL-USER 15 &gt; (mp:process-run-function "sleep in the background" nil 'sleep 10)
#&lt;MP:PROCESS Name "sleep in the background" Priority 850000 State "Running"&gt;

CL-USER 16 &gt; (mp:find-process-from-name "sleep in the background")
#&lt;MP:PROCESS Name "sleep in the background" Priority 0 State "Sleeping on mailbox"&gt;

CL-USER 17 &gt; (sleep 10)     ;; At this point the listener sleeps for ten seconds
NIL

CL-USER 18 &gt; (mp:find-process-from-name "sleep in the background")
NIL                         ;; The background process has finished its job and terminated

CL-USER 19 &gt;
</pre>

<p><strong>Warning!</strong> Note the difference between:</p>

<pre>(dotimes (i 20)
  (mp:process-run-function "One closure" ()
                           (lambda () (print i #.*standard-output*))))
</pre>
<p>and</p>
<pre>
(dotimes (i 20)
  (mp:process-run-function "Twenty different bindings" ()
                           (lambda (j) (print j #.*standard-output*))
                           i))
</pre>

<p>In the first case, all twenty threads share the same closure
variable <code>i</code>. The threads execute
<cite>asynchronously</cite> - in other words there's no way to tell
exactly when or in what order they'll execute. In this case (try it!)
the observed behaviour is that LispWorks initialises all 20 threads
before any of them have a chance to start running. By far the easiest
way of dealing with this is to ensure that variables which need to be
private to each thread are bound on a per-thread basis.</p>

<p><strong>Exercise:</strong> get two or three new threads running
simultaneously, and convince yourself they're all there.</p>


<a name="output"></a><h3>Where's my output?</h3>

<p>An obvious way to test whether threads are behaving as you imagine
they ought, is to get them to print messages to the listener. For
example, you might feel justified in trying something like:</p>

<pre>
CL-USER 23 &gt; (mp:process-run-function "test" () (lambda () (print 99)))
#&lt;MP:PROCESS Name "test" Priority 850000 State "Running"&gt;

CL-USER 24 &gt; ;; Where's my output?
</pre>

<p>Where indeed is your output? The answer is that your new thread has
a different <code>*standard-output*</code> to the listener, and that's
where your output has gone to. Here is how you might find out where
precisely that is:</p>

<pre>
CL-USER 25 &gt; (mp:process-run-function
              "" ()
              (lambda ()
                (print *standard-output* #.*standard-output*)))
#&lt;MP:PROCESS Name "" Priority 850000 State "Running"&gt;

#&lt;Synonym stream to *TERMINAL-IO*&gt;
CL-USER 26 &gt;
</pre>

<p><strong>Exercise:</strong> Open the console
(i.e. <code>*terminal-io*</code>) by evaluating <code>(read-char
*terminal-io*)</code>; type a <code>#\Newline</code> into the console
to return from <code>read-char</code>. Now you can prove directly where
a thread's output goes (by sending something there).</p>



<a name="waiting"></a><h3>Waiting</h3>

<p>In all the above examples, a thread is created to run a simple
function and then halt. In a typical application at least some of your
threads will run an <cite>event loop</cite> of some sort. An event
loop is a function which repeatedly waits for an external event to
occur. When an event is noticed, it is dispatched (maybe to another
thread) for processing and the event loop cycles back to its waiting
state. The "other thread" here might already exist (perhaps running an
event loop of its own) or might be created specifically to perform
this task (i.e. handle a single event) and then terminate.</p>

<p>It might be tempting to construct an event loop using
<code>cl:sleep</code>. For example:</p>

<pre>
(defun bogus-event-loop ()
  (loop
   (sleep 1)                        ; THIS IS WRONG
   (when (something-has-happened)
     (act-on-that-thing))))

(mp:process-run-function "Bogus event loop" ()
                         'bogus-event-loop)
</pre>

<p>This is a poor choice, because you're condemned to waiting for the
<code>sleep</code> to return before you can perform the wake-up
test. (Also, it's possible that your implementation cannot sleep one
single thread without sleeping the whole lisp process. In such cases,
any processing required before the predicate
<code>something-has-happened</code> can return true will never happen.)</p>

<p>Consider instead:</p>

<pre>
(defun improved-event-loop ()
  (loop
   (mp:process-wait "Waiting for something to happen"
                    'something-has-happened)
   (act-on-that-thing)))
</pre>

<p>The arguments to <code>mp:process-wait</code> are a string (which
you should use for describing what this thread is waiting for), a
function and optionally arguments to that function. The current thread
will effectively sleep until the function returns true. The function
can watch either internal state...</p>

<pre>
(defun flush-entries-to-file (entries-symbol max-length file)
  (loop
   ;; Wait until we have enough entries to justify going to disk.
   (mp:process-wait (format nil "Waiting for ~a entr~:@p" max-length)
                    (lambda ()
                      (>= (length (symbol-value entries-symbol)) max-length)))
   ;; In this example, don't bother to spawn off a new thread to
   ;; perform the task.
   (let ((entries (shiftf (symbol-value entries-symbol) nil)))
     (with-open-file (ostream file
                              :direction :output
                              :if-exists :append
			      :if-does-not-exist :create)
       (format ostream "~%Flushing entries:")
       (dolist (entry (reverse entries))
         (print entry ostream))))))

;; Test bed to drive the event loop
(defvar *test-entries* nil)
(defvar *test-file* "c:/temp/test-flush-entries.txt")
(defun test-flush-entries-to-file ()
  (let ((tester
         (mp:process-run-function "Test writing entries to file" ()
                                  'flush-entries-to-file
                                  '*test-entries*
                                  10
                                  *test-file*)))
    (dotimes (i 100)
      (push i *test-entries*)
      ;; Without the delay introduced by sleep, all 100 entries are
      ;; generated before the flusher has a chance to wake up.
      (sleep 0.1))
    (mp:process-kill tester)))
</pre>

<p>... or external state...</p>

<pre>
(defun flush-entries-from-file (file reporting-stream)
  (loop
   ;; Wait for given file to exist on disk.
   (mp:process-wait (format nil "Waiting for ~a" file)
                    'probe-file file)
   ;; Empty the file to the reporting-stream, being careful to
   ;; allow more contents to accumulate while this is happening.
   (format reporting-stream "~&amp;Reading ~a:~%" file)
   (let ((temp-file (format nil "~a.temp" file)))
     (rename-file file temp-file)
     (with-open-file (istream temp-file)
       (loop (let ((line (read-line istream nil)))
               (unless line
                 (return))
               (write-line line reporting-stream))))
     (delete-file temp-file))))

(defun test-flush-entries-from-file ()
  (delete-file *test-file*)
  (let ((tester
         (mp:process-run-function "Test reading entries from file" ()
                                  'flush-entries-from-file
                                  *test-file*
                                  *standard-output*)))
    ;; Use the previous example to create test data for this test.
    (test-flush-entries-to-log-file)
    (mp:process-kill tester)))
</pre>

<p>Although both of these examples were somewhat contrived, note their
intentions to preserve their data from external modification once the
waiting threads have woken up. In the first example,
<code>shiftf</code> is used to atomically retrieve a symbol-value and
reset it. In the above examples, this level of care didn't
particularly matter, but in some applications it may be important to
keep threads from trampling on each other's data.</p>

<p>Note also the use of <code>mp:process-kill</code> to terminate
unwanted threads when each test is complete.</p>

<p><strong>Exercise:</strong> Create and test a thread which will wait
until the symbol <code>foo</code> is <code>boundp</code> and then
announce the fact.</p>


<a name="state"></a><h3>Per-thread state</h3>

<p>Every thread in your lisp system has its own execution stack and
hence its own private state. The following aspects of state will
therefore vary between different threads:</p>

<ul>
<li>bindings of dynamic variables;</li>
<li><code>catch</code> tags;</li>
<li>condition handlers, <code>unwind-protect</code>, etc.;</li>
</ul>

<p>On the other hand, the following are globally <strong>set</strong>
rather than <strong>bound</strong> in a lisp system and so will not
vary between threads:</p>

<ul>
<li>definitions of functions, methods, classes, conditions, packages;</li>
<li>contents of any "compound" objects: cons cells, arrays, structure
objects, CLOS objects, hash-tables;</li>
<li>values of lexical variables in shared closures;</li>
<li>state of any stream;</li>
<li>symbol property-lists.</li>
</ul>

<p>To see how per-thread variable bindings can lead you astray,
consider the following examples:</p>

<pre>
CL-USER 34 &gt; (defvar *foo* nil)
*FOO*

CL-USER 35 &gt; (mp:process-run-function "" () (lambda () (setf *foo* 1)))
#&lt;MP:PROCESS Name "" Priority 850000 State "Running"&gt;

CL-USER 36 &gt; *foo*
1

CL-USER 37 &gt; (mp:process-run-function
              "Bind in new thread, can't see elsewhere." ()
              (lambda ()
                (let ((*foo* 2))
                  (sleep 5)
		  (setf *foo* 3)
                  (print 'done #.*standard-output*))))
#&lt;MP:PROCESS Name "" Priority 850000 State "Running"&gt;

CL-USER 38 &gt; *foo*
1

DONE
CL-USER 39 &gt; (let ((*foo* 4))
               (mp:process-run-function
                "Bind in old thread, can't see elsewhere." ()
                (lambda () (print *foo* #.*standard-output*))))
#&lt;MP:PROCESS Name "" Priority 850000 State "Running"&gt;

1
CL-USER 40 &gt;
</pre>

<p>In both lines 34 and 35, <code>*foo*</code> is globally
<strong>set</strong>. This means that every thread shares the symbol's
value. In line 37, <code>*foo*</code> is <strong>bound</strong> only
within the new thread; the original thread (i.e. the listener) does
not see this binding or the result of a <code>setf</code> within the
binding. Similarly, in line 39 the <strong>binding</strong> is present
only in the original thread. To create a binding in a new thread, use
<code>mp:*process-initial-bindings*</code>:</p>

<pre>
CL-USER 17 &gt; (let ((mp:*process-initial-bindings*
                    ;; Note the "dotted list" format - an unpleasant trap
		    ;; for the unwary. Note also that new value is pushed
		    ;; onto existing list so that system defaults aren't lost.
                    (cons '(*foo* . 5) mp:*process-initial-bindings*)))
               (mp:process-run-function
                "Bind around new thread." ()
                (lambda ()
                  (print *foo* #.*standard-output*))))
#&lt;MP:PROCESS Name "Bind around new thread." Priority 850000 State "Running"&gt;

5
CL-USER 18 &gt;
</pre>

<p><strong>Exercise:</strong> Explain why calling
<code>in-package</code> in one listener does not affect the package in
another.</p>

<a name="initializing"></a><h3>Initializing multithreading</h3>

<p><i>under construction</i></p>


<hr />
<table width="100%"><tr><td>
<a href="license.html">Copyright</a> &copy; 2002 The Common Lisp Cookbook Project
<address>http://cl-cookbook.sourceforge.net/</address>
</td><td align="right">
<a href="http://validator.w3.org/check/referer"><img
src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!"
height="31" width="88" /></a>
</td></tr></table>
<p>$Header$</p>
</body> </html>
